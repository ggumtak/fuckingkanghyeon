[Page 1]
컴퓨터공학과
Transact SQL 기본
SELECT - 3

[Page 2]
학습 목표
1. SQL 구문 기본 문법
   WITH ...
   SELECT ...
   FROM ...
   WHERE ...
   ORDER BY ...
   GROUP BY 함수...
   HAVING ...
[Ref] 교재 6장

[Page 3]
AdventureWorks2019.Sales.Customer 테이블
(SQL Query 창 스크린샷)
SELECT * FROM Sales.Customer;
-- 결과: 19,820개 행

[Page 4]
SQL Server Profiler 실행 - 1
도구(T) -> SQL Server Profiler(P) 실행
서버에 연결 창:
서버 유형: 데이터베이스 엔진
서버 이름: 117.16.183.9
인증: SQL Server 인증
로그인: sa
암호: *****

[Page 5]
SQL Server Profiler 실행 - 2
추적 속성 창:
일반 탭
추적 이름: COUNT() 함수 성능 측정
템플릿 사용: TSQL_Duration
실행 버튼 클릭

[Page 6]
SQL Server Profiler 실행 - 2
(SQL Management Studio 화면)
USE AdventureWorks2019;
SELECT * FROM Sales.Customer;
SELECT COUNT(*) FROM Sales.Customer;
-- 쿼리 실행

[Page 7]
SQL Server Profiler 확인
(Profiler 화면)
EventClass: SQL:BatchCompleted
TextData:
  SELECT COUNT(*) FROM Sales.Customer; (Duration: 10ms)
  SELECT * FROM Sales.Customer; (Duration: 77ms)

[Page 8]
Having 절 사용 이유
USE sqlDB;
SELECT userID AS [사용자],
       SUM(price * amount) AS [총구매액]
  FROM buyTbl 
  GROUP BY userID;

• 총 구매액이 1,000 원 초과인 사용자만 선택하려면?
SELECT userID AS [사용자],
       SUM(price * amount) AS [총구매액]
  FROM buyTbl
  WHERE SUM(price * amount) > 1000 -- Error 발생 (집계함수는 WHERE절 사용 불가)
  GROUP BY userID;

[Page 9]
Having 절 : 집계값의 조건 - 1
SELECT userID AS [사용자],
       SUM(price * amount) AS [총구매액]
  FROM buyTbl
  GROUP BY userID
  HAVING SUM(price * amount) > 1000; 
  -- GROUP BY 다음에 기술

[Page 10]
Having 절 : 집계값의 조건 - 2
SELECT userID AS [사용자],
       SUM(price * amount) AS [총구매액]
  FROM buyTbl
  GROUP BY userID
  HAVING SUM(price * amount) > 1000
  ORDER BY SUM(price * amount); -- 정렬 추가

[Page 11]
Having 절 : 집계값의 조건 - 3
SELECT userID AS [사용자],
       SUM(price * amount) AS [총구매액]
  FROM buyTbl
  GROUP BY userID
  HAVING [총구매액] > 1000 -- Error (Alias 사용 불가)
  ORDER BY [총구매액];

[Page 12]
Having 절 : 집계함수의 조건 - 4
SELECT userID AS [사용자],
       SUM(price * amount) AS [총구매액]
  FROM buyTbl
  GROUP BY userID
  HAVING SUM(price * amount) > 1000 
  ORDER BY [총구매액];

[Page 13]
GROUP BY 사용 예
• 구매테이블에서 분류별 구입비용의 합계 산출
SELECT groupName, SUM(price * amount) AS [비용]
  FROM buyTbl
  GROUP BY groupName;

[Page 14]
GROUP BY : ROLLUP() 함수 – 1
• 설명
 – 자동 총계 계산
• 사용 예
SELECT groupName, SUM(price * amount) AS [비용]
  FROM buyTbl
  GROUP BY ROLLUP (groupName);
-- 결과에 NULL(총계) 행이 추가됨

[Page 15]
GROUPING_ID() 함수
• 설명
 – 데이터인지 합계인지 구분
SELECT groupName, SUM(price * amount) AS [비용],
       GROUPING_ID(groupName) AS [추가행여부]
  FROM buyTbl
  GROUP BY ROLLUP(groupName);
-- 결과: 추가행여부가 1이면 합계 행임

[Page 16]
GROUP BY : ROLLUP() 함수 – 2
• 개별값과 총계 사용 예
USE sqlDB;
SELECT groupName, num, 
       SUM(price * amount) AS [비용]
  FROM buyTbl
  GROUP BY ROLLUP (groupName, num);

[Page 17]
CUBE() 테스트를 위한 Table 생성
USE sqlDB;
CREATE TABLE cubeTbl
 (prodName NCHAR(3), color NCHAR(2), amount INT);

INSERT INTO cubeTbl VALUES('컴퓨터', '검정', 11);
INSERT INTO cubeTbl VALUES('컴퓨터', '파랑', 22);
INSERT INTO cubeTbl VALUES('모니터', '검정', 33);
INSERT INTO cubeTbl VALUES('모니터', '파랑', 44);

SELECT * FROM cubeTbl;

[Page 18]
GROUP BY : CUBE() - 1
• 다차원 정보의 데이터를 요약
SELECT prodName, color, SUM(amount) AS [수량합계]
  FROM cubeTbl
  GROUP BY CUBE (color, prodName);
-- 결과: 각 컬럼별 소합계 및 전체 합계가 모두 표시됨

[Page 19]
GROUP BY : CUBE() - 2
SELECT color, prodName, SUM(amount) AS [수량합계]
  FROM cubeTbl
  GROUP BY CUBE (prodName, color);
-- 순서를 바꾸어도 결과 집합의 내용은 유사함 (정렬 순서 차이 등)

[Page 20]
WITH 절과 CTE
• 개념
 – WITH 절은 CTE(Common Table Expression)을 표현하기 위한 구문임
 – CTE는 뷰, 파생테이블, 임시테이블을 대신할 수 있으며 더 간결하게 표현
 – ANSI-SQL99 표준으로 제안됨
 – 재귀적 CTE와 비 재귀적 CTE로 구분됨
• 비 재귀적 CTE
 – 단순한 형태로 복잡한 쿼리문을 단순화 시키는데 적합
 – 구문 형식
   WITH CTE_테이블이름(열이름목록)
   AS
   ( <쿼리문> )
   SELECT 열이름목록 FROM CTE_테이블이름 ;

[Page 21]
WITH 절과 CTE 없는 SELECT 구문
• 사용자별 총구매액 구하기
USE sqlDB;
SELECT userID AS [사용자],
       SUM(price * amount) AS [총구매액]
  FROM buyTbl GROUP BY userID;

• 사용자별 총구매액을 총구매액의 역순으로 구하기
SELECT userID AS [사용자],
       SUM(price*amount) AS [총구매액]
  FROM buyTbl GROUP BY userID 
  ORDER BY [총구매액] DESC;

[Page 22]
비재귀적 CTE
• CTE의 예
WITH [사용자별 총구매액] ([사용자], [총구매액])
AS
( SELECT userID, SUM(price * amount)
  FROM buyTbl GROUP BY userID )
SELECT * FROM [사용자별 총구매액] 
  ORDER BY [총구매액] DESC;

[Page 23]
비재귀적 CTE 연습
• 회원테이블(userTbl)에서 각 지역별로 키가 가장 큰 사람들에 대한 키의 평균값 구하기
1. 각 지역별로 키가 가장 큰 사람
   SELECT addr, MAX(height) FROM userTbl GROUP BY addr
2. WITH 구문으로 묶어 줌
   WITH [지역별 최고키] (addr, maxHeight)
   AS
   ( SELECT addr, MAX(height) FROM userTbl GROUP BY addr )
3. 키의 평균을 구하는 쿼리문 작성
   SELECT AVG(maxHeight*1.0) AS [각 지역별 최고키의 평균] 
     FROM [지역별 최고키];

[Page 24]
중복 CTE 예
WITH
[사용자별 총구매액] ( userID, total )
 AS
 (SELECT userID, SUM(price*amount) FROM buyTbl GROUP BY userID ),
[총구매금액] (sumtotal)
 AS
 (SELECT SUM(total) FROM [사용자별 총구매액] ),
[구매평균] (sumavg)
 AS
 (SELECT sumtotal / (SELECT count(*) FROM buyTbl) 
  FROM [총구매금액])
SELECT * FROM [구매평균];

[Page 25]
Recursive CTE
• 설명
 – 자기 자신을 반복적으로 호출하는 의미
 – 회사의 조직도 표현 등에 사용 가능
• 구문 형식
WITH CTE_테이블이름(열목록)
AS
(
 <쿼리문1 : SELECT * FROM 테이블A >
 UNION ALL
 <쿼리문2 : SELECT * FROM 테이블A JOIN CTE_테이블이름>
)
SELECT * FROM CTE_테이블이름;

[Page 26]
학습 요약
SQL 구문 기본 문법
WITH ...
SELECT ...
 FROM ...
 WHERE ...
 ORDER BY ...
 GROUP BY 함수...
 HAVING ...

[Page 27]
과제 - 1
• 아래 예시와 같이 강의록 3~7페이지의 실습을 진행하고 SQL Server Profiler 화면의 스크린샷을 제출하시오.

[Page 28]
과제 - 2
• 우측의 그림과 같이 강의록에 있는 모든 SQL 구문을 새 쿼리 창에 입력해서 실행시켜 본 후, 새 쿼리 창을 닫으면 .sql 형식으로 저장할 수 있습니다.
• 전체 실습 내용을 06-4.sql 로 저장해서 제출 하시오.

[Page 30]
Transact SQL 기본
INSERT, UPDATE, DELETE

[Page 31]
학습 목표
1. SQL 구문 기본 문법
   INSERT
   UPDATE
   DELETE
[Ref] 교재 6장

[Page 32]
SQL의 분류
• DML (Data Manipulation Language : 데이터 조작 언어)
 – 데이터의 선택, 삽입, 수정, 삭제에 사용
 – SELECT, INSERT, UPDATE, DELETE 가 해당
 – 대상은 테이블의 행
• DDL (Data Definition Language : 데이터 정의 언어)
 – 데이터베이스 개체를 생성/삭제/변경하는데 사용
 – CREATE, DROP, ALTER 등이 해당
• DCL (Data Control Language : 데이터 제어 언어)
 – 사용자에게 권한 부여시에 주로 사용
 – GRANT, REVOKE, DENY 등이 해당

[Page 33]
INSERT
• 설명
 – 데이터 삽입
• 구문 형식
   INSERT [INTO] 테이블명 [(열이름1, 열이름2, …)] 
   VALUES (값1, 값2 …)
• 사용 예
USE tempDB;
CREATE TABLE testTbl1 (id int, userName nchar(3), age int);
INSERT INTO testTbl1 VALUES (1, '홍길동', 25);
INSERT INTO testTbl1 (id, userName) VALUES (2, '한가인');
INSERT INTO testTbl1 (userName, age, id) VALUES ('조인성', 29, 3);
SELECT * FROM testTbl1;

[Page 34]
INSERT : IDENTITY/DEFAULT 컬럼
• IDENTITY 와 DEFAULT 컬럼이 있는 테이블 생성
USE tempdb;
CREATE TABLE testTbl2
 ( id int IDENTITY,
   userName nchar(3),
   age int,
   nation nchar(4) DEFAULT '대한민국');
• IDENTITY 열에는 입력 값 생략 / DEFAULT 값 지정
INSERT INTO testTbl2 VALUES ('머스크', 50, '미국');
INSERT INTO testTbl2 VALUES ('강동원', 27, DEFAULT);
SELECT * FROM testTbl2;

[Page 35]
INSERT : IDENTITY 컬럼
• 강제로 IDENTITY 값을 입력하고 싶다면
SET IDENTITY_INSERT testTbl2 ON;
INSERT INTO testTbl2(id, userName, age, nation) 
 VALUES (11, '키아누', 31, '미국');
SELECT * FROM testTbl2;

[Page 36]
INSERT : IDENTITY 관련 Tip - 1
• 테이블에 대한 정보 확인
 EXEC sp_help testTbl2;

[Page 37]
INSERT : IDENTITY 관련 Tip - 2
• 특정 테이블에 설정된 IDENTITY 값 확인
SET IDENTITY_INSERT testTbl2 OFF;
INSERT INTO testTbl2 VALUES ('홍길동', 60, '대한민국');
SELECT IDENT_CURRENT('testTbl2');
• 최근 생성된 IDENTITY 값 확인
SELECT @@IDENTITY

[Page 38]
SEQUENCE
• IDENTITY와 같은 효과를 냄
• 오라클과 같은 방식을 제공하기 위해 새로 추가된 개체
• SEQUENCE 테스트를 위한 테이블 생성
USE tempdb;
CREATE TABLE testTbl3
 ( id int,
   userName nchar(3),
   age int,
   nation nchar(4) DEFAULT '대한민국');

[Page 39]
SEQUENCE – 생성 및 사용
CREATE SEQUENCE idSEQ
 START WITH 1 -- 시작값
 INCREMENT BY 1 ; -- 증가값
INSERT INTO testTbl3 
 VALUES (NEXT VALUE FOR idSEQ, '강동원', 27, DEFAULT);
INSERT INTO testTbl3 
 VALUES (NEXT VALUE FOR idSEQ, '머스크', 31, '미국');
SELECT * FROM testTbl3;

[Page 40]
SEQUENCE – 수정
ALTER SEQUENCE idSEQ
 RESTART WITH 12; -- 시작값을 다시 설정
INSERT INTO testTbl3 
 VALUES (NEXT VALUE FOR idSEQ, '다꾸앙', 23, '일본');
SELECT * FROM testTbl3;

[Page 41]
SEQUENCE – 특정 범위의 값 반복 - 1
USE tempdb;
CREATE TABLE testTbl4 (id INT);
CREATE SEQUENCE cycleSEQ
 START WITH 100
 INCREMENT BY 100
 MINVALUE 100 -- 최소값
 MAXVALUE 300 -- 최대값
 CYCLE ; -- 반복설정

[Page 42]
SEQUENCE – 특정 범위의 값 반복 - 2
INSERT INTO testTbl4 VALUES (NEXT VALUE FOR cycleSEQ);
INSERT INTO testTbl4 VALUES (NEXT VALUE FOR cycleSEQ);
INSERT INTO testTbl4 VALUES (NEXT VALUE FOR cycleSEQ);
INSERT INTO testTbl4 VALUES (NEXT VALUE FOR cycleSEQ);
SELECT * FROM testTbl4;

[Page 43]
SEQUENCE – DEFAULT와 함께 사용 - 1
USE tempdb;
CREATE SEQUENCE autoSEQ
 START WITH 1
 INCREMENT BY 1 ;
CREATE TABLE testTbl5
 ( id int DEFAULT (NEXT VALUE FOR autoSEQ) ,
   userName nchar(3)
 ) ;

[Page 44]
SEQUENCE – DEFAULT와 함께 사용 - 2
INSERT INTO testTbl5 VALUES (DEFAULT, '강동원');
INSERT INTO testTbl5 (userName) VALUES ('머스크');
INSERT INTO testTbl5 (userName) VALUES ('다꾸앙');
SELECT * FROM testTbl5;

[Page 45]
대량의 Sample 데이터 생성 – INSERT (1)
• 형식
   INSERT INTO 대상테이블이름 [(열이름1, 열이름2, …)]
   SELECT 문 ;
• SELECT 구문의 결과를 대상 테이블에 저장
 – 대상 테이블이 이미 존재할 때 사용
 – 실행 전에 대상 테이블을 생성해 놓고 사용

[Page 46]
대량의 Sample 데이터 생성 – INSERT (2)
• 사용 예
USE tempDB;
CREATE TABLE testTbl6 
 ( id int, 
   Fname nvarchar(50), 
   Lname nvarchar(50));
INSERT INTO testTbl6
 SELECT BusinessEntityID, 
        FirstName, LastName
 FROM AdventureWorks2019.Person.Person ;
SELECT * FROM testTbl6;

[Page 47]
대량의 Sample 데이터 생성 – SELECT
• 형식
   SELECT 필드(들) INTO 대상테이블이름
   FROM 읽어올테이블명
• SELECT 구문의 결과를 대상 테이블에 저장
 -> 대상 테이블이 존재하지 않는 경우 사용
• 사용 예
SELECT BusinessEntityID, 
       FirstName, LastName 
  INTO testTbl7
  FROM AdventureWorks2019.Person.Person ;
SELECT * FROM testTbl7;

[Page 48]
UPDATE : 데이터 수정 - 1
• 구문 형식
   UPDATE 테이블이름
   SET 열이름1=변경값1, 열이름2=변경값2, …
   [WHERE 조건식]
• 사용 예
USE tempDB;
SELECT * FROM testTbl6
 WHERE Fname = 'Kim';

[Page 49]
UPDATE : 데이터 수정 - 2
UPDATE testTbl6
 SET Lname = '없음'
 WHERE Fname = 'Kim';
SELECT * FROM testTbl6
 WHERE Fname = 'Kim';
USE sqlDB;
SELECT * FROM buyTbl;

[Page 50]
UPDATE : 데이터 수정 - 3
USE sqlDB;
UPDATE buyTbl 
 SET price = price * 1.5 ;
SELECT * FROM buyTbl;

[Page 51]
DELETE : 데이터 삭제
• 구문 형식
   DELETE 테이블이름
   [ WHERE 조건식 ]
• 사용 예
USE tempDB;
DELETE testTbl6 
 WHERE Fname = 'Kim';
SELECT * FROM testTbl6
 WHERE Fname = 'Kim';

[Page 52]
대용량 테이블 삭제 실습 - 1
• 실습 목표
 – 테이블을 삭제하기 위한 방법(Delete, Truncate, Drop)들을 알아 보고, 성능에 효율적인 것을 확인
• 실습 준비
USE tempDB;
SELECT * INTO bigTbl1 FROM AdventureWorks2019.Sales.SalesOrderDetail;
SELECT * INTO bigTbl2 FROM AdventureWorks2019.Sales.SalesOrderDetail;
SELECT * INTO bigTbl3 FROM AdventureWorks2019.Sales.SalesOrderDetail;

[Page 53]
대용량 테이블 삭제 실습 - 2
• SQL Server Profiler 실행
 – 강의록 “06-4. Transact SQL 기본 - SELECT(4).pptx” p.3 참조
• 삭제 작업 실행
DELETE FROM bigTbl1;        // 레코드 삭제
TRUNCATE TABLE bigTbl2;     // 트랜잭션 로그 확인 없이 모든 레코드 삭제
DROP TABLE bigTbl3;         // 테이블 삭제

[Page 54]
대용량 테이블 삭제 실습 - 3
• 수행 시간 확인
(Profiler 스크린샷: TRUNCATE와 DROP이 DELETE보다 훨씬 빠름)

[Page 55]
학습 요약
SQL 구문 기본 문법
INSERT
UPDATE
DELETE

[Page 56]
과제 - 1
• 우측의 그림과 같이 강의록에 있는 모든 SQL 구문을 새 쿼리 창에 입력해서 실행시켜 본 후, 새 쿼리 창을 닫으면 .sql 형식으로 저장할 수 있습니다.
• 전체 실습 내용을 06-5.sql 로 저장해서 제출 하시오.

[Page 57]
과제 - 2
• 아래 예시와 같이 강의록 23~25페이지의 실습을 진행하고 SQL Server Profiler 화면의 스크린샷 을 제출하시오.

[Page 59]
Transact SQL 기본
MERGE

[Page 60]
학습 목표
1. SQL 구문 기본 문법
   MERGE
[Ref] 교재 6장

[Page 61]
MERGE : 조건부 데이터 병합
• 하나의 문장에서 INSERT, UPDATE, DELETE 구문을 선택적으로 수행할 수 있는 구문
• 구문 형식
MERGE 
 [ TOP ( expression ) [ PERCENT ] ] 
 [ INTO ] <target_table>
 USING <source_table> 
 ON <merge_search_condition> 
 [ WHEN MATCHED ... THEN UPDATE ... ]
 [ WHEN NOT MATCHED [ BY TARGET ] ... THEN INSERT ... ]
 [ WHEN NOT MATCHED BY SOURCE ... THEN DELETE ... ] ;

[Page 62]
MERGE 구문의 활용 실습 - 1
• 실습 시나리오
1. memberTBL 에는 기존 회원의 정보가 존재
2. 회원의 가입, 변경, 탈퇴가 생겼을 때 직접 memberTBL 에 입력/수정/삭제를 하지 않고
3. 가입, 변경, 탈퇴가 발생했을 때, changeTBL 에 신규가입/주소변경/회원탈퇴 등의 사유를 저장
4. MERGE 구문을 이용해서 changeTBL 의 내용을 memberTBL 에 적용

[Page 63]
MERGE 구문 활용 실습 - 2
• memberTBL 생성
USE sqlDB;
SELECT userID, name, addr 
 INTO memberTBL 
 FROM userTbl;
SELECT * FROM memberTBL;

[Page 64]
MERGE 구문 활용 실습 - 3
• changeTBL 생성
CREATE TABLE changeTBL
 ( changeType NCHAR(4), -- 변경 사유
   userID char(8) ,
   name nvarchar(10) ,
   addr nchar(2) );
INSERT INTO changeTBL VALUES
 ('신규가입', 'TPN', '티파니', '미국'),
 ('주소변경', 'LSG', null, '제주'),
 ('주소변경', 'LJB', null, '영국'),
 ('회원탈퇴', 'BBK', null, null),
 ('회원탈퇴', 'SSK', null, null) ;
SELECT * FROM changeTBL;

[Page 65]
MERGE 구문 활용 실습 - 4
• MERGE 문을 이용한 병합
MERGE memberTBL AS M -- 변경될 테이블 (Target)
 USING changeTBL AS C -- 변경할 기준이 되는 테이블 (Source)
 ON M.userID = C.userID -- userID를 기준으로 두 테이블을 비교
 -- target에 source의 행이 없고, 사유가 '신규가입'이라면
 WHEN NOT MATCHED AND changeType = '신규가입' THEN
   INSERT (userID, name, addr) VALUES(C.userID, C.name, C.addr)
 -- target에 source의 행이 있고, 사유가 '주소변경'이라면
 WHEN MATCHED AND changeType = '주소변경' THEN
   UPDATE SET M.addr = C.addr
 -- target에 source의 행이 있고, 사유가 '회원탈퇴'라면
 WHEN MATCHED AND changeType = '회원탈퇴' THEN
   DELETE ;

[Page 66]
MERGE 구문 활용 실습 - 5
• 병합 확인
SELECT * FROM memberTBL;
(실행 전후 데이터 비교 그림)

[Page 67]
학습 요약
SQL 구문 기본 문법
MERGE

[Page 68]
과제
• 우측의 그림과 같이 강의록에 있는 모든 SQL 구문을 새 쿼리 창에 입력해서 실행시켜 본 후, 새 쿼리 창을 닫으면 .sql 형식으로 저장할 수 있습니다.
• 전체 실습 내용을 06-6.sql 로 저장해서 제출 하시오.

[Page 70]
Transact SQL 고급
Data Type, Variable

[Page 71]
학습 목표
1. SQL 고급
   Data Type
   Variable
[Ref] 교재 7장

[Page 72]
SQL Server의 데이터 형식 : 숫자형
(데이터 형식 테이블 표)
BIT: 0 또는 1
INT: 정수
SMALLINT, TINYINT, BIGINT
DECIMAL, NUMERIC: 고정 정밀도와 배율
FLOAT, REAL: 부동 소수점
MONEY, SMALLMONEY: 화폐 단위

[Page 73]
SQL Server의 데이터 형식 : 문자형
(데이터 형식 테이블 표)
CHAR: 고정길이
VARCHAR: 가변길이
NCHAR, NVARCHAR: 유니코드
TEXT, NTEXT: 대용량 텍스트 (이전 버전 호환용)
BINARY, VARBINARY, IMAGE: 이진 데이터

[Page 74]
SQL Server의 데이터 형식 : 날짜/시간
(데이터 형식 테이블 표)
DATETIME, DATETIME2: 날짜와 시간
DATE: 날짜만
TIME: 시간만
DATETIMEOFFSET: 표준 시간대 포함
SMALLDATETIME

[Page 75]
날짜와 시간 Data Type Test - 1
SELECT CAST('2020-10-20 12:35:29.123' AS datetime) AS 'datetime';
SELECT CAST('2020-10-20 12:35:29.1234567 +12:15' AS datetime2(7)) AS 'datetime2';
SELECT CAST('2020-10-20 12:35:29.1234567 +12:15' AS date) AS 'date';

[Page 76]
날짜와 시간 Data Type Test - 2
SELECT CAST('2020-10-20 12:35:29.1234567 +12:15' AS time(7)) AS 'time';
SELECT CAST('2020-10-20 12:35:29.1234567 +12:15' AS datetimeoffset(7)) AS 'datetimeoffset';
SELECT CAST('2020-10-20 12:35:29.123' AS smalldatetime) AS 'smalldatetime';

[Page 77]
SQL Server의 데이터 형식 : 기타
(데이터 형식 테이블 표)
ROWVERSION: 자동 생성 고유 이진 숫자
SYSNAME: 데이터베이스 개체 이름
CURSOR
TABLE
UNIQUEIDENTIFIER: GUID
SQL_VARIANT
HIERARCHYID
XML
GEOMETRY / GEOGRAPHY

[Page 78]
ISO Standard Data Type
SQL Server 데이터 타입과 ISO 표준 데이터 타입 매핑 표

[Page 79]
ISO Standard Data Type 사용 - 1
USE tempDB;
CREATE TABLE isoTable
(charData Character(2),
 varcharData Character Varying(2),
 varbinaryData Binary Varying,
 decimalData Dec,
 floatData Double Precision,
 intData Integer,
 ncharData National Character(2),
 nvarcharData National Character Varying(2),
 rowversionData Timestamp 
);

[Page 80]
ISO Standard Data Type 사용 - 2
-- 결과 확인
EXEC sp_columns @table_name = 'isoTable'

[Page 81]
사용자 정의 데이터 형식 - 1
• User- Defined Data Types : UDT
• 개념: 기존의 데이터 형식에 별칭을 붙이는 것
• 구문 형식
   CREATE TYPE 사용자정의데이터형식_이름
   FROM 기존데이터형식 NULL 또는 NOT NULL
• 사용 예
   CREATE TYPE myTypeName FROM nchar(10) NOT NULL;

[Page 82]
사용자 정의 데이터 형식 - 2
(SSMS GUI를 이용한 생성 방법 스크린샷)

[Page 83]
LOB (Large Object)
• VARCHAR(MAX), NVARCHAR(MAX), VARBINARY(MAX)
 – LOB(Large Object: 대량의 데이터)를 저장하기 위해서 지원

[Page 84]
Unicode Data
– 문자 데이터를 저장하고 관리할 경우, 각 국가별 코드 페이지가 달라서 서로 호환되지 않는 문제점을 해결
– 데이터형식은 nchar, nvarchar, ntext 가 있음
– 리터럴 입력 시에는 N'문자열' 형식으로 사용
USE tempDB;
CREATE TABLE uniTest(korName nvarchar(10));
GO
INSERT INTO uniTest VALUES (N'홍길동'); -- OK
INSERT INTO uniTest VALUES ('홍길동'); -- OK (경고 발생 가능성)
INSERT INTO uniTest VALUES (n'홍길동'); -- ERROR (소문자 n 안됨)

[Page 85]
CHAR(n) vs. NCHAR(n)
CREATE TABLE person (
 id int, -- 사용자 ID
 korName nchar(10), -- 한글 이름 (한글 사용)
 engName char(20), -- 영문 이름 (영어만 사용)
 email char(30) -- 이메일 주소 (영어&기호만 사용)
);

[Page 86]
변수의 사용
• 일시적으로 사용되며, 실행 후에는 바로 소멸
• 사용 형식
 변수의 선언: DECLARE @변수이름 데이터형식
 변수에 값 대입: SET @변수이름 = 변수의값
 변수의 값 출력: SELECT @변수이름

[Page 87]
실습 : 변수의 사용 - 1
USE sqlDB;
DECLARE @myVar1 INT;
DECLARE @myVar2 SMALLINT, @myVar3 DECIMAL(5,2);
DECLARE @myVar4 NCHAR(20);

SET @myVar1 = 5;
SET @myVar2 = 3;
SET @myVar3 = 4.25;
SET @myVar4 = '가수 이름 ==> ';

SELECT @myVar1;
SELECT @myVar2 + @myVar3;
SELECT @myVar4, Name FROM userTbl WHERE height > 180;

[Page 88]
실습 : 변수의 사용 - 2
USE sqlDB;
DECLARE @myVar5 INT;
SET @myVAR5 = 3;
SELECT TOP(@myVar5) Name, height 
 FROM userTbl ORDER BY height

[Page 89]
학습 요약
• SQL 고급
  Data Type
  Variable

[Page 90]
과제
• 우측의 그림과 같이 강의록에 있는 모든 SQL 구문을 새 쿼리 창에 입력해서 실행시켜 본 후, 새 쿼리 창을 닫으면 .sql 형식으로 저장할 수 있습니다.
• 전체 실습 내용을 07-1.sql 로 저장해서 제출 하시오.

[Page 92]
Transact SQL 고급
함수 - 1

[Page 93]
학습 목표
1. SQL 고급
   시스템 제공 함수 (Function)
   –데이터 타입 변환 함수
   –구성 함수
   –날짜/시간 함수
   –수치 연산 함수
   –문자열 함수
   –메타 데이터 함수
[Ref] 교재 7장

[Page 94]
함수 (Function)
• 정의
 – 주어진 인수를 이용해서 하나의 결과를 반환
 – C# 언어의 Method와 유사
 – 기본 제공 함수를 사용하거나, 필요에 따라 사용자 정의 함수를 만들 수 있음
• 구문 형식
 – 함수명 ( 인수 [, 인수, …])

[Page 95]
데이터형식 관련 함수
• 개념
 – 데이터의 형식을 변환해 주는 함수
• 관련 함수
 – CAST ( expression AS 데이터형식 [ (길이 ) ])
 – CONVERT ( 데이터형식[(길이)] , expression [ , 스타일 ] )
 – TRY_CONVERT ( ... ) -> 변환 실패 시 NULL 반환
 – PARSE (문자열 AS 데이터형식)
 – TRY_PARSE (문자열 AS 데이터형식) -> 변환 실패 시 NULL 반환

[Page 96]
정수를 실수로 변환 예 - 1
USE sqlDB;
SELECT AVG(amount) AS [평균구매개수] FROM buyTbl ;
SELECT AVG( CONVERT(FLOAT, amount) ) AS [평균구매개수] FROM buyTbl ;
SELECT AVG(TRY_CONVERT(FLOAT, amount)) AS [평균구매개수] FROM buyTbl ;

[Page 97]
정수를 실수로 변환 예 - 2
SELECT price, amount, price/amount AS [단가/수량] FROM buyTbl ;
SELECT price, amount, 
       CAST(CAST(price AS FLOAT)/amount AS DECIMAL(10,2)) AS [단가/수량] 
  FROM buyTbl ;

[Page 98]
문자열 데이터 형식 변환 예
– 문자열 ➔ DATE
SELECT PARSE('2020년 10월 23일' AS DATE) ;
– PARSE / TRY_PARSE
SELECT PARSE('123.45' AS INT) ; --Error
SELECT TRY_PARSE('123.45' AS INT) ;

[Page 99]
명시적 형 변환 / 암시적 형 변환
• 명시적 형변환
 - CAST() 또는 CONVERT()를 사용해서 형을 변환하는 것
• 암시적 형변환
 - CAST() 또는 CONVERT()를 사용하지 않고, 내부적으로 자동으로 형이 변환되는 것
 - 정수 + 정수 = 정수, 정수 + 실수 = 실수
 - 사용자의 착오로 인해서 엉뚱한 결과가 나올 수 있으므로 주의 필요

[Page 100]
명시적 / 암시적 형 변환 비교 - 1
DECLARE @myVar1 char(3) ;
SET @myVar1 = '100' ;
SELECT @myVar1 + '200' ; -- 문자 + 문자 (정상)
SELECT @myVar1 + 200 ; -- 문자 + 정수 (정상: 정수로 변환)
SELECT @myVar1 + 200.0 ; -- 문자 + 실수 (정상: 실수 변환)

[Page 101]
명시적 / 암시적 형 변환 비교 - 2
DECLARE @myVar1 char(3) ;
SET @myVar1 = '100' ;
SELECT @myVar1 + '200' ; -- 문자와 문자를 더함(정상)
SELECT CAST(@myVar1 AS INT) + 200 ; -- 정수로 변환 후 연산
SELECT CAST(@myVar1 AS DECIMAL(5,1)) + 200.0 ; -- 실수로 변환 후 연산

[Page 102]
명시적 형 변환 예 - 1
DECLARE @myVar2 DECIMAL(10,5) ;
SET @myVar2 = 10.12345 ;
SELECT CAST(@myVar2 AS NCHAR(5)) ; -- Over Flow Error
SELECT CAST(@myVar2 AS NCHAR(11)) ;

[Page 103]
명시적 형 변환 예 - 2
DECLARE @myVar3 DECIMAL(10,5) ;
SET @myVar3 = 10.12345 ;
SELECT CAST(@myVar3 AS INT) ;

DECLARE @myVar4 DECIMAL(10,5) ;
SET @myVar4 = 10.12345 ;
SELECT CAST(@myVar4 AS DECIMAL(10,2)) ;

[Page 104]
데이터 형식 변환 표
(데이터 타입 간 명시적/암시적 변환 가능 여부를 나타내는 표 이미지)

[Page 105]
Scalar 함수
• 개념: 단일 값 반환
• 스칼라 함수의 일부 예
 @@VERSION: SQL Server 버전 정보
 GETDATE(): 현재 날짜와 시간
 ABS(): 절대값
 DB_ID(), DB_NAME(): DB ID 또는 이름
 LEFT(), RIGHT(): 문자열 자르기
 EOMONTH(): 달의 마지막 날

[Page 106]
구성 함수 - 1
• 개념: 현재 SQL Server의 구성에 대한 정보를 반환
@@DATEFIRST, @@DBTS, @@LANGID, @@LANGUAGE, @@LOCK_TIMEOUT, @@MAX_CONNECTIONS, @@MAX_PRECISION 등

[Page 107]
구성 함수 - 2
@@NESTLEVEL, @@OPTIONS, @@REMSERVER, @@SERVERNAME, @@SERVICENAME, @@SPID, @@TEXTSIZE, @@VERSION 등

[Page 108]
구성 함수 예
SELECT @@LANGID;
SELECT @@SERVERNAME;
SELECT @@SERVICENAME;
SELECT @@SPID AS 'ID', SYSTEM_USER AS [로그인사용자], USER AS [사용자];
SELECT @@VERSION;

[Page 109]
날짜 및 시간 관련 함수 - 1
• 개념: 날짜와 시간 관련 연산 함수
SYSDATETIME(), GETDATE(), DATEPART(), DAY(), MONTH(), YEAR(), DATEFROMPARTS()

[Page 110]
날짜 및 시간 관련 함수 - 2
DATEDIFF(), DATENAME(), DATEADD(), EOMONTH()

[Page 111]
날짜 및 시간 관련 함수 예 - 1
SELECT SYSDATETIME(), GETDATE();
SELECT DATEADD(day, 100, '2020/10/10');
SELECT DATEDIFF(week, GETDATE(), '2022/10/20');
SELECT DATENAME(weekday, '2022/10/20');

[Page 112]
날짜 및 시간 관련 함수 예 - 2
SELECT DATEPART(year, GETDATE());
SELECT MONTH('2022/10/20');
SELECT DATEFROMPARTS('2022','10','20');
SELECT EOMONTH('2020-10-20');
SELECT EOMONTH(GETDATE(), 3);

[Page 113]
수치 연산 함수
• 개념: 수학적 연산을 수행하고 숫자 값을 반환
ABS, ACOS, ASIN, ATAN, CEILING, COS, COT, DEGREES, EXP, FLOOR, LOG, LOG10, PI, POWER, RADIANS, RAND, ROUND, SIGN, SIN, SQRT, SQUARE, TAN

[Page 114]
수치 연산 함수 예
SELECT ABS(-100);
SELECT ROUND(1234.5678, 2), ROUND(1234.5678, -2);
SELECT RAND();
SELECT SQRT(10);
SELECT POWER(3,2);

[Page 115]
문자열 함수
• 개념: 문자열 입력 값에 대한 작업을 수행
ASCII, CHAR, CHARINDEX, CONCAT, FORMAT, LEFT, LEN, LOWER, LTRIM, NCHAR, PATINDEX, REPLACE, REPLICATE, REVERSE, RIGHT, RTRIM, SPACE, STR, STUFF, SUBSTRING, UNICODE, UPPER

[Page 116]
문자열 함수 예 - 1
SELECT ASCII('A'), CHAR(65);
SELECT CONCAT('SQL ', 'SERVER ', 2019);
SELECT UNICODE('가'), NCHAR(44032);
SELECT CHARINDEX('Server','SQL Server 2019');
SELECT LEFT('SQL Server 2019', 3), RIGHT('SQL Server 2019', 4);
SELECT SUBSTRING(N'대한민국화이팅', 3, 2);
SELECT LEN('SQL Server 2019');

[Page 117]
문자열 함수 예 - 2
SELECT LOWER('abcdEFGH'), UPPER('abcdEFGH');
SELECT LTRIM(' 공백앞뒤두개 '), RTRIM(' 공백앞뒤두개 ');
SELECT REPLACE ('SQL Server 2019', 'Server', '서버');
SELECT REPLICATE ('SQL', 5);
SELECT REVERSE ('SQL Server 2019');
SELECT SPACE(5);
SELECT STUFF('SQL 서버 2019', 5, 2, 'Server');
SELECT FORMAT ( GETDATE() , 'dd/MM/yyyy' ) ;

[Page 118]
메타 데이터 함수
• 개념: 데이터베이스와 데이터베이스 개체에 대한 정보를 반환
@@PROCID, DB_ID, OBJECT_ID, COL_LENGTH 등 다양한 메타 데이터 함수 목록

[Page 119]
메타 데이터 함수 예
USE sqlDB; 
SELECT COL_LENGTH('userTbl','name');
SELECT DB_ID(N'AdventureWorks2019');
SELECT DB_NAME(5);
SELECT OBJECT_ID(N'sqlDB.dbo.userTbl');
SELECT OBJECT_NAME(885578193);

[Page 120]
학습 요약
• SQL 고급
  시스템 제공 함수 (Function)
  – 데이터 타입 변환 함수
  – 구성함수
  – 날짜/시간 함수
  – 수치 연산 함수
  – 문자열 함수
  – 메타 데이터 함수

[Page 121]
과제
• 우측의 그림과 같이 강의록에 있는 모든 SQL 구문을 새 쿼리 창에 입력해서 실행시켜 본 후, 새 쿼리 창을 닫으면 .sql 형식으로 저장할 수 있습니다.
• 전체 실습 내용을 07-2.sql 로 저장해서 제출 하시오.

[Page 123]
Transact SQL 고급
함수 – 2
PIVOT
Join

[Page 124]
학습 목표
1. SQL 고급
   시스템 제공 함수 (Function)
   – 순위 함수
   – 분석 함수
   PIVOT
   Join
[Ref] 교재 7장

[Page 125]
실습 : MAX 데이터 형식 활용 - 1
USE tempDB;
CREATE TABLE maxTbl (col1 VARCHAR(MAX), col2 NVARCHAR(MAX));
INSERT INTO maxTbl VALUES( REPLICATE('A',1000000), REPLICATE('가',1000000));
SELECT LEN(col1) AS [VARCHAR(MAX)], LEN(col2)AS [NVARCHAR(MAX)] FROM maxTbl;

[Page 126]
실습 : MAX 데이터 형식 활용 - 2
DELETE FROM maxTbl;
INSERT INTO maxTbl VALUES(
 REPLICATE( CAST('A' AS VARCHAR(MAX)), 1000000 ),
 REPLICATE( CONVERT(NVARCHAR(MAX) , '가'), 1000000) ) ;
SELECT LEN(col1) AS [VARCHAR(MAX)], LEN(col2)AS [NVARCHAR(MAX)] FROM maxTbl;

[Page 127]
실습 : MAX 데이터 형식 활용 - 3
UPDATE maxTbl 
 SET col1 = REPLACE( (SELECT col1 FROM maxTbl),'A', 'B'),
     col2 = REPLACE( (SELECT col2 FROM maxTbl),'가', '나') ;
SELECT REVERSE((SELECT col1 FROM maxTbl)) ;
SELECT SUBSTRING((SELECT col2 FROM maxTbl),999991, 10) ;

[Page 128]
실습 : MAX 데이터 형식 활용 - 4
UPDATE maxTbl SET
 col1 = STUFF( (SELECT col1 FROM maxTbl), 999991, 10, REPLICATE('C', 10)),
 col2 = STUFF( (SELECT col2 FROM maxTbl), 999991, 10, REPLICATE('다',10)) ;
SELECT REVERSE((SELECT col1 FROM maxTbl)) ;
SELECT REVERSE((SELECT col2 FROM maxTbl)) ;

[Page 129]
실습 : MAX 데이터 형식 활용 - 5
UPDATE maxTbl 
 SET col1.WRITE('DDDDD',999996, 5), 
     col2.WRITE('라라라라라',999996, 5) ;
SELECT REVERSE((SELECT col1 FROM maxTbl)) ;
SELECT REVERSE((SELECT col2 FROM maxTbl)) ;

[Page 130]
순위 함수
• 개념: 순번(또는 순위)를 처리하기 위한 함수
• 종류: RANK(), NTILE(), DENSE_RANK(), ROW_NUMBER()
• OVER절 구문 형식
 <순위함수이름>( ) OVER(
 [PARTITION BY <partition_by_list>]
 ORDER BY <order_by_list>)

[Page 131]
순위 함수 ROW_NUMBER( ) 예 - 1
USE sqlDB;
SELECT ROW_NUMBER( ) 
 OVER(ORDER BY height DESC) AS [키큰순위],
 name, addr, height
 FROM userTbl ;

[Page 132]
순위 함수 ROW_NUMBER( ) 예 - 2
SELECT ROW_NUMBER( ) 
 OVER(ORDER BY height DESC, name ASC) AS [키큰순위],
 name, addr, height
 FROM userTbl ;

[Page 133]
순위 함수 ROW_NUMBER( ) 예 - 3
SELECT addr, 
 ROW_NUMBER( ) 
 OVER(PARTITION BY addr 
 ORDER BY height DESC, name ASC) 
 AS [지역별키큰순위],
 name, height
 FROM userTbl ;

[Page 134]
순위 함수 RANK( ) 예
SELECT RANK( ) OVER(ORDER BY height DESC) AS [키큰순위],
 name, addr, height
 FROM userTbl ;

[Page 135]
순위 함수 DENSE_RANK( ) 예
SELECT DENSE_RANK( ) OVER(ORDER BY height DESC) AS [키큰순위],
 name, addr, height
 FROM userTbl ;

[Page 136]
순위 함수 NTILE( ) 예 - 1
SELECT NTILE(2) OVER(ORDER BY height DESC) AS [반번호],
 name, addr, height
 FROM userTbl ;

[Page 137]
순위 함수 NTILE( ) 예 - 2
SELECT NTILE(4) OVER(ORDER BY height DESC) AS [반번호],
 name, addr, height
 FROM userTbl ;

[Page 138]
분석 함수 - 1
• 개념: 집계 함수와 같이 행 그룹을 기반으로 계산되지만, 여러 개의 행을 반환 (이동 평균, 누계 등)
• 함수 설명
 – LEAD: 다음 레코드의 값과 비교
 – LAG: 이전 레코드의 값과 비교

[Page 139]
분석 함수 - 2
 – FIRST_VALUE: 정렬된 값 세트의 첫 번째 값을 반환
 – CUME_DIST: 값 그룹에서 지정한 값의 상대적 위치를 계산
 – PERCENTILE_CONT: 열 값의 연속 분포를 기반으로 백분위수를 계산

[Page 140]
분석 함수 LEAD() 예
USE sqlDB;
SELECT name, addr, height AS [키],
 height - (LEAD(height, 1, 0) OVER (ORDER BY height DESC)) 
 AS [다음 사람과 키 차이]
 FROM userTbl ;

[Page 141]
분석 함수 LAG() 예
SELECT name, addr, height AS [키],
 height - (LAG(height, 1, 0) OVER (ORDER BY height DESC)) 
 AS [앞 사람과 키 차이]
 FROM userTbl ;

[Page 142]
분석 함수 FIRST_VALUE() 예
SELECT addr, name, height AS [키],
 height - ( FIRST_VALUE(height) 
 OVER (PARTITION BY addr ORDER BY height DESC) ) 
 AS [지역별 가장 큰 키와 차이]
 FROM userTbl ;

[Page 143]
분석 함수 CUM_DIST() 예
USE sqlDB;
SELECT addr, name, height AS [키],
 (CUME_DIST() 
 OVER (PARTITION BY addr ORDER BY height DESC)) * 100 
 AS [누적인원 백분율%]
 FROM userTbl ;

[Page 144]
분석 함수 PERCENTILE_CONT() 예
SELECT DISTINCT addr, 
 PERCENTILE_CONT(0.5) 
 WITHIN GROUP (ORDER BY height) OVER (PARTITION BY addr) 
 AS [지역별 키의 중앙값]
 FROM userTbl ;

[Page 145]
PIVOT / UNPIVOT 연산자
• PIVOT: 여러 레코드의 한 열에 저장된 값을 여러 개의 열 이름으로 변환하여 출력
• UNPIVOT: PIVOT의 반대 연산
• Syntax
   PIVOT ( 집계함수(열) FOR 새로운 열로 변경할 열이름 IN (열 목록) AS 피벗이름 )

[Page 146]
실습 : PIVOT 연산자 사용 예 - 1
USE tempdb;
CREATE TABLE pivotTest (uName NCHAR(3), season NCHAR(2), amount INT );
INSERT INTO pivotTest VALUES ('김범수', '겨울', 10), ('윤종신', '여름', 15), ... (생략) ... ;
SELECT * FROM pivotTest;

[Page 147]
실습 : PIVOT 연산자 사용 예 - 2
SELECT * FROM pivotTest
 PIVOT ( SUM(amount)
 FOR season
 IN ([봄],[여름],[가을],[겨울])) AS resultPivot ;

[Page 148]
Join

[Page 149]
Join
• 조인의 개념: 두 개 이상의 테이블을 서로 묶어서 하나의 결과집합으로 만들어 내는 것
• 종류: INNER JOIN, OUTER JOIN, CROSS JOIN

[Page 150]
INNER JOIN
• 개념: 조인의 조건이 만족되는 행만 출력
• 구문 형식
   SELECT <열 목록>
   FROM <첫 번째 테이블>
   INNER JOIN <두 번째 테이블>
   ON <조인될 조건>
   [WHERE 검색조건]

[Page 151]
INNER JOIN 예 - 1
USE sqlDB;
SELECT * 
 FROM buyTbl
 INNER JOIN userTbl
 ON buyTbl.userid = userTbl.userid

[Page 152]
INNER JOIN 실행 과정
(데이터베이스명: sqlDB, 회원 테이블 userTbl과 구매 테이블 buyTbl의 조인 과정 다이어그램)

[Page 153]
INNER JOIN 결과
(조인된 결과 테이블 스크린샷)

[Page 154]
INNER JOIN 예 - 2
USE sqlDB;
SELECT * 
 FROM buyTbl
 INNER JOIN userTbl
 ON buyTbl.userid = userTbl.userid
 WHERE buyTbl.userid = 'JYP';

[Page 155]
INNER JOIN의 결과 행 및 작동순서
(작동 순서 설명 다이어그램)

[Page 156]
학습 요약
SQL 고급
시스템 제공 함수 (Function)
– 순위 함수
– 분석 함수
PIVOT
Join

[Page 157]
과제 - 1
• 우측의 그림과 같이 강의록에 있는 모든 SQL 구문을 새 쿼리 창에 입력해서 실행시켜 본 후, 새 쿼리 창을 닫으면 .sql 형식으로 저장할 수 있습니다.
• 전체 실습 내용을 07-3.sql 로 저장해서 제출 하시오.

[Page 159]
Transact SQL 고급
Join (2)
Etc.

[Page 160]
학습 목표
1. SQL 고급
   Join (2)
   UNION
   EXCEPT
   INTERSECT
   Recursive CTE
[Ref] 교재 7장, 6장

[Page 161]
JOIN 시의 필드명 기술 방법 - 1
USE sqlDB;
SELECT buyTbl.userid, name, prodName, addr, 
 mobile1 + mobile2 AS [연락처]
 FROM buyTbl INNER JOIN userTbl
 ON buyTbl.userid = userTbl.userid;

[Page 162]
JOIN 시의 필드명 기술 방법 - 2
SELECT buyTbl.userid, userTbl.name, buyTbl.prodName, userTbl.addr, 
 userTbl.mobile1 + userTbl.mobile2 AS [연락처]
 FROM buyTbl INNER JOIN userTbl
 ON buyTbl.userid = userTbl.userid;

[Page 163]
테이블의 별칭(Alias) 사용 - 1
SELECT B.userid, U.name, B.prodName, U.addr, 
 U.mobile1 + U.mobile2 AS [연락처]
 FROM buyTbl B INNER JOIN userTbl U
 ON B.userid = U.userid

[Page 164]
테이블의 별칭(Alias) 사용 - 2
SELECT U.userid, U.name, B.prodName, U.addr, 
 U.mobile1 + U.mobile2 AS [연락처]
 FROM userTbl U INNER JOIN buyTbl B
 ON U.userid = B.userid
 ORDER BY U.userid;

[Page 165]
테이블의 별칭(Alias) 사용 - 3
SELECT U.userid, U.name, B.prodName, U.addr, 
 U.mobile1 + U.mobile2 AS [연락처]
 FROM userTbl U INNER JOIN buyTbl B
 ON U.userid = B.userid
 WHERE B.userid = 'JYP';

[Page 166]
JOIN 과 DISTINCT
• 구매이력이 있는 사용자 정보만 선택
SELECT DISTINCT U.userid, U.name, U.addr
 FROM userTbl U INNER JOIN buyTbl B
 ON U.userid = B.userid
 ORDER BY U.userid ;

[Page 167]
JOIN 과 EXISTS ()
SELECT U.userid, U.name, U.addr
 FROM userTbl U
 WHERE EXISTS ( SELECT *
 FROM buyTbl B
 WHERE U.userid = B.userid ) ;

[Page 168]
실습6: 세 개 테이블의 내부 조인
• 실습 목표: 3개 테이블의 조인 방법 습득
• 실습 테이블 샘플: stdName(학생), clubName(동아리), stdclubTbl(학생_동아리)

[Page 169]
실습6: 세 개 테이블의 내부 조인을 위한 테이블 생성 구문
USE sqlDB;
CREATE TABLE stdTbl ... (생략)
CREATE TABLE clubTbl ... (생략)
CREATE TABLE stdclubTbl ... (생략)
INSERT INTO ... (데이터 삽입)

[Page 170]
실습6: 세 개 테이블의 내부 조인 - 1
SELECT S.stdName, S.addr, C.clubName, C.roomNo
 FROM stdTbl S INNER JOIN stdclubTbl SC
 ON S.stdName = SC.stdName
 INNER JOIN clubTbl C
 ON SC.clubName = C.clubName
 ORDER BY S.stdName;

[Page 171]
실습6: 세 개 테이블의 내부 조인 - 2
SELECT C.clubName, C.roomNo, S.stdName, S.addr
 FROM stdTbl S INNER JOIN stdclubTbl SC
 ON SC.stdName = S.stdName
 INNER JOIN clubTbl C
 ON SC.clubName = C.clubName
 ORDER BY C.clubName;

[Page 172]
OUTER JOIN
• 개념: 내부조인은 조인의 조건이 만족되지 않는 행은 출력되지 않지만, 외부조인은 조건이 만족되지 않는 행도 함께 출력
• 구문 형식
   SELECT <열 목록>
   FROM <첫 번째 테이블(LEFT 테이블)>
   <LEFT | RIGHT | FULL> OUTER JOIN 
   <두 번째 테이블(RIGHT 테이블)> 
   ON <조인될 조건>

[Page 173]
INNER JOIN 예
SELECT U.userid, U.name, B.prodName, 
 U.addr, U.mobile1 + U.mobile2 AS [연락처]
FROM userTbl U
 INNER JOIN buyTbl B
 ON U.userid = B.userid 
ORDER BY U.userid

[Page 174]
OUTER JOIN (INNER JOIN 과 비교)
SELECT U.userid, U.name, B.prodName, 
 U.addr, U.mobile1 + U.mobile2 AS [연락처]
FROM userTbl U
 LEFT OUTER JOIN buyTbl B
 ON U.userid = B.userid 
ORDER BY U.userid

[Page 175]
RIGHT OUTER JOIN 예
SELECT U.userid, U.name, B.prodName, U.addr, 
 U.mobile1 + U.mobile2 AS [연락처]
 FROM buyTbl B RIGHT OUTER JOIN userTbl U
 ON U.userid = B.userid
ORDER BY U.userid;

[Page 176]
OUTER JOIN 예
• 구매이력이 없는 사용자의 정보 선택
SELECT U.userid, U.name, B.prodName, 
 U.addr, U.mobile1 + U.mobile2 AS [연락처]
 FROM userTbl U LEFT OUTER JOIN buyTbl B
 ON U.userid = B.userid
 WHERE B.prodName IS NULL
 ORDER BY U.userid;

[Page 177]
실습7: 외부 조인 - 1
• 실습 목표
 – 동아리에 가입하지 않은 학생도 출력 ➔ LEFT JOIN
 – 가입학생이 한 명도 없는 동아리도 출력 ➔ RIGHT JOIN
 – 모두 출력 ➔ FULL JOIN

[Page 178]
실습7: 외부 조인 - 2
• 동아리에 가입하지 않은 학생도 출력
SELECT S.stdName, S.addr, C.clubName, C.roomNo
 FROM stdTbl S LEFT OUTER JOIN stdclubTbl SC
 ON S.stdName = SC.stdName
 LEFT OUTER JOIN clubTbl C
 ON SC.clubName = C.clubName
 ORDER BY S.stdName;

[Page 179]
실습7: 외부 조인 - 2
• 가입학생이 한 명도 없는 동아리도 출력
SELECT C.clubName, C.roomNo, S.stdName, S.addr
 FROM stdTbl S LEFT OUTER JOIN stdclubTbl SC
 ON SC.stdName = S.stdName
 RIGHT OUTER JOIN clubTbl C
 ON SC.clubName = C.clubName
 ORDER BY C.clubName ;

[Page 180]
실습7: 외부 조인 - 3
• 동아리에 가입되지 않은 학생 및 학생이 한 명도 없는 동아리를 모두 출력
 SELECT S.stdName, S.addr, C.clubName, C.roomNo
 FROM stdTbl S FULL OUTER JOIN stdclubTbl SC
 ON S.stdName = SC.stdName
 FULL OUTER JOIN clubTbl C
 ON SC.clubName = C.clubName
 ORDER BY S.stdName ;

[Page 181]
CROSS JOIN (상호조인) - 1
• 개념: 한쪽 테이블의 모든 행들과 다른 쪽 테이블의 모든 행을 조인시키는 방법 (대용량 테이블 생성시 사용)
• 상호 조인 예
   SELECT * FROM buyTbl CROSS JOIN userTbl;

[Page 182]
CROSS JOIN (상호조인) - 2
USE AdventureWorks2019;
SELECT COUNT_BIG(*) AS [데이터개수]
 FROM Sales.SalesOrderDetail
 CROSS JOIN Sales.SalesOrderHeader;

[Page 183]
UNION
• UNION [ALL] 개념
 - UNION: 중복 제거하고 합침
 - UNION ALL: 중복 허용하고 합침
• 예
SELECT stdName, addr FROM stdTbl
UNION ALL
SELECT clubName, roomNo FROM clubTbl;

[Page 184]
EXCEPT
• 개념: 두 번째 쿼리에 해당하는 것을 제외
• 예
SELECT name, mobile1 + mobile2 AS [전화번호] FROM userTbl
EXCEPT
SELECT name,mobile1 + mobile2 FROM userTbl WHERE mobile1 IS NULL ;

[Page 185]
INTERSECT
• 개념: 양쪽에 모두 존재하는 레코드만 조회 (교집합)
• 예
SELECT name, mobile1 + mobile2 AS [전화번호] FROM userTbl
INTERSECT
SELECT name, mobile1 + mobile2 FROM userTbl WHERE mobile1 IS NULL ;

[Page 186]
Recursive CTE
• 설명: 자기 자신을 반복적으로 호출 (조직도 등에 사용)
• 구문 형식
WITH CTE_테이블이름(열목록)
AS
( <쿼리문1> UNION ALL <쿼리문2> )
SELECT * FROM CTE_테이블이름;

[Page 187]
실습4: 회사 조직도 출력
• 실습 목표: 재귀적 CTE를 사용해서 회사의 조직도를 출력하는 방법 습득

[Page 188]
조직도용 Table 생성
(테이블 생성 및 데이터 삽입 SQL 구문)

[Page 189]
SELF JOIN (자체조인)
• 개념: 자기자신과 자기자신이 조인
• 예
SELECT A.emp AS [부하직원], B.emp AS [직속상관], 
 B.department AS [직속상관부서]
 FROM empTbl A INNER JOIN empTbl B
 ON A.manager = B.emp
 WHERE A.emp = '이영업'

[Page 190]
CTE를 이용한 Level 구하기
WITH empCTE(empName, mgrName, dept, level)
 AS (
 SELECT emp, manager, department , 0 FROM empTbl WHERE manager IS NULL 
 UNION ALL
 SELECT AA.emp, AA.manager, AA.department, BB.level + 1
 FROM empTbl AS AA INNER JOIN empCTE AS BB ON AA.manager = BB.empName
 )
SELECT * FROM empCTE ORDER BY dept, level;

[Page 191]
CTE를 이용한 Level 시각화
(Level에 따라 들여쓰기를 적용하여 직원이름 출력하는 SQL 구문)

[Page 192]
학습 요약
• SQL 고급
  Join (2)
  UNION
  EXCEPT
  INTERSECT
  Recursive CTE

[Page 193]
과제
• 우측의 그림과 같이 강의록에 있는 모든 SQL 구문을 새 쿼리 창에 입력해서 실행시켜 본 후, 새 쿼리 창을 닫으면 .sql 형식으로 저장할 수 있습니다.
• 전체 실습 내용을 07-4.sql 로 저장해서 제출 하시오.

[Page 195]
Transact SQL 고급
SQL Programming

[Page 196]
학습 목표
1. SQL 고급
   SQL Programming
[Ref] 교재 7장

[Page 197]
IF... ELSE...
• 개념: 참과 거짓에 의해서 실행해야 할 구문이 다를 때 사용
• 구문 형식
   IF <부울 표현식> BEGIN ... END ELSE BEGIN ... END

[Page 198]
IF... ELSE... 사용 예 - 1
DECLARE @var1 INT 
SET @var1=100
IF @var1 = 100
 BEGIN PRINT '@var1이 100이다' END
ELSE
 BEGIN PRINT '@var1이 100이아니다.' END

[Page 199]
IF... ELSE... 사용 예 - 2
(입사일과 현재 날짜의 차이를 계산하는 예제 코드)

[Page 200]
IF... ELSE... 사용 예 - 3
(근무 연수에 따라 메시지를 출력하는 예제 코드)

[Page 201]
CASE 문
• 개념: 여러 개의 경우에 따라서 서로 다른 구문을 수행할 경우 (IF문보다 간결)
• 구문 형식
 CASE
 WHEN (조건식) THEN ...
 ELSE ...
 END

[Page 202]
IF 문 사용 예
(학점 계산을 IF문을 사용하여 구현한 예제)

[Page 203]
CASE 문 사용 예
(학점 계산을 CASE문을 사용하여 구현한 예제)

[Page 204]
실습8: CASE 문 실습
• 실습 목표: 구매한 액수에 따라서 고객 등급 분류
• 구현 예
SELECT U.userid, U.name, SUM(price*amount) AS [총구매액],
 CASE
  WHEN (SUM(price*amount) >= 1500) THEN N'최우수고객'
  ...
  ELSE N'유령고객'
 END AS [고객등급]
 ...

[Page 205]
실습8: CASE 문 실습 결과
(실행 결과 테이블 스크린샷)

[Page 206]
WHILE, BREAK, CONTINUE
• WHILE: 참인 동안 반복
• BREAK: 반복문 탈출
• CONTINUE: 반복문의 처음으로 이동
• 사용 예
DECLARE @i INT = 1
DECLARE @hap BIGINT = 0
WHILE (@i <= 100)
BEGIN ... END

[Page 207]
WHILE, BREAK, CONTINUE 문 예
(1부터 100까지 합계 구하기, 7의 배수는 제외, 합계가 1000 넘으면 종료)

[Page 208]
GOTO
• 개념: 지정한 위치로 무조건 이동
• 사용 예
 ... GOTO endprint ...
 endprint:
 PRINT ...

[Page 209]
WAITFOR
• 개념: 코드의 실행을 일시정지
• 사용 예
 WAITFOR DELAY '00:00:05'; -- 5초간 멈춤
 WAITFOR TIME '23:59'; -- 지정한 시각까지 멈춤

[Page 210]
TRY... CATCH...
• 개념: 오류를 처리하는 데 편리
• 구문 형식
 BEGIN TRY ... END TRY
 BEGIN CATCH ... END CATCH

[Page 211]
TRY... CATCH... 예 - 1
(INSERT 시 오류 발생 상황을 TRY CATCH로 처리하는 예제)

[Page 212]
TRY... CATCH... 예 - 2
(CATCH 블록에서 ERROR 관련 함수들을 사용하여 오류 정보를 출력하는 예제)

[Page 213]
RAISEERROR
• 개념: 오류를 강제로 발생
• 구문 형식: RAISERROR ( ... )

[Page 214]
THROW
• 개념: 오류를 강제로 발생 (RAISERROR보다 간단)
• 구문 형식: THROW ...

[Page 215]
EXEC(동적 SQL)
• 개념: 변수에 저장된 SQL문장(텍스트 형태)을 실행시켜 줌
• 사용 예
DECLARE @sql VARCHAR(100)
SET @sql = 'SELECT * FROM userTbl WHERE userid = ''EJW'''
EXEC(@sql)

[Page 216]
EXEC(동적 SQL) 예
(현재 날짜를 이용하여 테이블 이름을 동적으로 생성하는 예제)

[Page 217]
학습 요약
• SQL 고급
  SQL Programming

[Page 218]
과제
• 우측의 그림과 같이 강의록에 있는 모든 SQL 구문을 새 쿼리 창에 입력해서 실행시켜 본 후, 새 쿼리 창을 닫으면 .sql 형식으로 저장할 수 있습니다.
• 전체 실습 내용을 07-5.sql 로 저장해서 제출 하시오.

[Page 220]
Table과 Schema

[Page 221]
학습 목표
1. Table
2. Schema
 • 생성
 • 수정
 • 삭제
 • 사용
[Ref] 교재 8장

[Page 222]
테이블
– 실제 데이터가 저장되는 장소
– 행(Column, Field)과 열(Row, Record)로 구성
– 모든 동작은 레코드(Record) 단위로 이루어짐

[Page 223]
테이블 생성 구문 형식
CREATE TABLE ... (구문 설명)

[Page 224]
테이블의 제약 조건
• 데이터의 무결성을 지키기 위해 제한된 조건
• 제약조건 6가지
 – PRIMARY KEY, FOREIGN KEY, UNIQUE, CHECK, DEFAULT, NULL 값 허용

[Page 225]
Primary Key (기본 키) 제약 조건
• 기본 개념: 행을 구분하는 식별자, 중복 불가, NULL 불가

[Page 226]
Primary Key 설정 예 - 1
CREATE TABLE userTbl ( userID char(8) NOT NULL PRIMARY KEY, ... );

[Page 227]
Primary Key 설정 예 - 2
CREATE TABLE userTbl ( ... CONSTRAINT PK_userTbl_userID PRIMARY KEY, ... );

[Page 228]
Primary Key 설정 예 – 3
ALTER TABLE userTbl ADD CONSTRAINT PK_userTbl_userID PRIMARY KEY (userID);

[Page 229]
Primary Key 설정 예 – 4
(두 개 이상의 열을 합쳐서 기본 키로 설정하는 예)
ALTER TABLE prodTbl ADD CONSTRAINT ... PRIMARY KEY (prodCode, prodID);

[Page 230]
Foreign Key (외래 키) 제약 조건
• 기본 개념: 두 테이블 간의 관계 선언, 데이터 무결성 보장

[Page 231]
Foreign Key 설정 예 - 1
CREATE TABLE buyTbl ( ... FOREIGN KEY REFERENCES userTbl(userID), ... );

[Page 232]
Foreign Key 설정 예 - 2
CREATE TABLE buyTbl ( ... CONSTRAINT FK_userTbl_buyTbl FOREIGN KEY REFERENCES userTbl(userID) ... );

[Page 233]
Foreign Key 설정 예 - 3
ALTER TABLE buyTbl ADD CONSTRAINT ... FOREIGN KEY (userID) REFERENCES userTbl (userID);

[Page 234]
Foreign Key 설정 예 - 4
(ON UPDATE CASCADE 옵션 사용 예)

[Page 235]
Unique 제약 조건
• 기본 개념: 중복되지 않는 유일한 값 (Null값 1개 허용)

[Page 236]
Unique 제약 조건 예 - 1
CREATE TABLE userTbl ( ... email char(30) NULL UNIQUE );

[Page 237]
Unique 제약 조건 예 - 2
CREATE TABLE userTbl ( ... email char(30) NULL CONSTRAINT AK_email UNIQUE );

[Page 238]
Check 제약 조건
• 기본 개념: 입력되는 데이터를 점검 (조건 위배 시 입력 안됨)

[Page 239]
Check 제약 조건 예 - 1
(출생년도, 휴대폰 국번, 키 범위 등을 CHECK 제약조건으로 설정하는 예)

[Page 240]
Check 제약 조건 예 - 2
(WITH NOCHECK 옵션을 사용하여 기존 자료는 검사하지 않고 제약조건 추가)

[Page 241]
Default 정의
• 기본 개념: 데이터 입력 시 값을 생략하면 자동으로 입력되는 값 정의

[Page 242]
Default 예 - 1
CREATE TABLE userTbl ( ... birthYear int NOT NULL DEFAULT YEAR(GETDATE()), ... );

[Page 243]
Default 예 - 2
(INSERT 문에서 default 키워드 사용 예)

[Page 244]
NULL 값 허용
• NULL / NOT NULL

[Page 245]
임시 테이블
• 개념: 임시로 잠깐 사용되는 테이블 (#: 로컬, ##: 전역)
• 삭제 시점: DROP TABLE, SQL Server 재시작, 연결 끊김 등

[Page 246]
실습5: 임시 테이블 사용 예 - 1
(#tempTbl, ##tempTbl 생성 및 조회)

[Page 247]
실습5: 임시 테이블 사용 예 - 2
(다른 세션에서의 조회 가능 여부 확인)

[Page 248]
테이블의 삭제
DROP TABLE 테이블이름

[Page 249]
테이블 수정 구문
ALTER TABLE ... ADD / DROP COLUMN / ALTER COLUMN / ADD CONSTRAINT / DROP CONSTRAINT

[Page 250]
테이블 수정 예 - 1
(열 추가, 열 삭제, 열 데이터 형식 변경 예제)

[Page 251]
테이블 수정 예 - 2
(열 이름 변경, 제약 조건 추가/삭제 예제)

[Page 252]
스키마
• 개념: 데이터베이스 내 개체들을 관리하는 묶음 (기본값 dbo)
• 형식: 데이터베이스_이름.스키마_이름.개체_이름

[Page 253]
실습7: Schema 생성
• 목표: 스키마 생성 및 테이블 생성

[Page 254]
실습7: Schema 및 테이블 생성 구문
CREATE SCHEMA userSchema;
CREATE TABLE userSchema.userTBL ...;

[Page 255]
실습7: 생성된 내용
(SSMS 개체 탐색기 화면)

[Page 256]
학습 요약
• Table
• Schema

[Page 257]
과제 - 1
• 우측의 그림과 같이 강의록에 있는 모든 SQL 구문을 새 쿼리 창에 입력해서 실행시켜 본 후, 새 쿼리 창을 닫으면 .sql 형식으로 저장할 수 있습니다.
• 전체 실습 내용을 08-1.sql 로 저장해서 제출 하시오.

[Page 258]
과제 - 2
• 우측 예시와 같이 [실습 7] 의 실습을 진행한 후 SSMS 전체 화면의 스크린샷을 제출하시오.