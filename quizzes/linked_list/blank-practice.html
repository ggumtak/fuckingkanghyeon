<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>백지복습 | 연결 리스트 코드 연습</title>
    <link rel="stylesheet" href="../../shared/styles.css">

    <!-- Prism for reference code only -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>

    <style>
        .main-content {
            transition: margin-right 0.3s ease;
        }

        body.reference-open .main-content {
            margin-right: 45%;
        }

        .practice-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }

        .practice-header h2 {
            color: var(--accent);
            font-size: 1.2rem;
            font-weight: 600;
        }

        .editor-container {
            background: #1e1e1e;
            border-radius: var(--radius-lg, 12px);
            border: 1px solid var(--code-border, #333);
            overflow: hidden;
        }

        .editor-wrapper {
            display: flex;
            min-height: 500px;
        }

        .line-numbers {
            padding: 16px 12px;
            background: rgba(0, 0, 0, 0.3);
            color: #858585;
            text-align: right;
            user-select: none;
            border-right: 1px solid #333;
            font-family: 'JetBrains Mono', 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.8;
            min-width: 45px;
        }

        .practice-editor {
            flex: 1;
            padding: 16px;
            background: transparent;
            color: #d4d4d4;
            border: none;
            outline: none;
            resize: none;
            font-family: 'JetBrains Mono', 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.8;
            white-space: pre;
            overflow-x: auto;
        }

        .practice-editor::placeholder {
            color: #5c6370;
        }

        .practice-controls {
            display: flex;
            gap: 14px;
            margin: 24px 0;
            flex-wrap: wrap;
        }

        /* Reference Panel */
        .reference-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 45%;
            max-width: 550px;
            min-width: 320px;
            height: 100vh;
            background: var(--bg-secondary, #1E1F20);
            border-left: 1px solid var(--border);
            z-index: 1500;
            display: flex;
            flex-direction: column;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        .reference-panel.show {
            transform: translateX(0);
        }

        .reference-panel-header {
            padding: 14px 20px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .reference-panel-header h4 {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .reference-panel-body {
            flex: 1;
            overflow-y: auto;
            padding: 0;
        }

        .reference-panel-body pre {
            margin: 0;
            padding: 16px;
            font-size: 0.85rem;
            line-height: 1.7;
            background: transparent !important;
        }

        .reference-panel-body code {
            font-family: 'JetBrains Mono', monospace;
        }

        .tips-section {
            background: var(--bg-card);
            border-radius: var(--radius-md);
            padding: 20px 24px;
            margin-bottom: 28px;
            border: 1px solid var(--border);
        }

        .tips-section h3 {
            font-size: 0.95rem;
            color: var(--accent);
            margin-bottom: 12px;
        }

        .tips-section ul {
            list-style: none;
            color: var(--text-secondary);
            font-size: 0.88rem;
        }

        .tips-section li {
            padding: 6px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .tips-section li::before {
            content: '→';
            color: var(--accent);
        }

        kbd {
            background: var(--bg-tertiary);
            padding: 2px 8px;
            border-radius: 4px;
            border: 1px solid var(--border);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85em;
        }

        /* Line highlight in reference */
        .ref-line {
            display: block;
            padding: 0 8px;
            margin: 0 -8px;
            transition: background 0.15s;
        }

        .ref-line.active {
            background: rgba(168, 199, 250, 0.15);
            border-left: 3px solid var(--accent);
            padding-left: 5px;
        }

        @media (max-width: 900px) {
            .reference-panel {
                width: 100%;
                max-width: 100%;
            }

            body.reference-open .main-content {
                margin-right: 0;
            }
        }
    </style>
</head>

<body>
    <div class="container main-content">
        <header>
            <h1>📝 백지복습 모드</h1>
            <p class="subtitle">코드를 직접 타이핑하며 연결 리스트를 완전히 내 것으로!</p>
        </header>

        <a href="../../index.html" class="btn btn-back" style="margin-bottom:24px;">← 메인으로</a>

        <div class="tips-section">
            <h3>💡 사용법</h3>
            <ul>
                <li><kbd>:</kbd> 입력 후 Enter → 자동 들여쓰기</li>
                <li>빈 줄에서 Enter → 들여쓰기 한 단계 해제</li>
                <li><kbd>Tab</kbd> → 들여쓰기 / <kbd>Shift+Tab</kbd> → 들여쓰기 제거</li>
                <li><kbd>Backspace</kbd> (들여쓰기 영역) → 4칸 삭제</li>
                <li>📖 참조 코드에서 하이라이팅 확인!</li>
            </ul>
        </div>

        <div class="practice-header">
            <h2>🖊️ 코드 직접 작성</h2>
        </div>

        <div class="editor-container">
            <div class="editor-wrapper">
                <div class="line-numbers" id="lineNumbers">1</div>
                <textarea class="practice-editor" id="practiceEditor" placeholder="여기에 코드를 작성하세요...

class Node():
    def __init__(self):
        self.data = None
        self.link = None" spellcheck="false"></textarea>
            </div>
        </div>

        <div class="practice-controls">
            <button class="btn btn-primary" onclick="clearEditor()">🗑️ 전체 지우기</button>
            <button class="btn btn-secondary" onclick="toggleReference()">📖 참조 코드 보기</button>
            <button class="btn btn-secondary" onclick="copyToClipboard()">📋 복사</button>
        </div>
    </div>

    <!-- Reference Panel with syntax highlighting -->
    <div class="reference-panel" id="referencePanel">
        <div class="reference-panel-header">
            <h4>📚 참조 코드 (정답)</h4>
            <button class="btn btn-back" onclick="toggleReference()" style="padding:6px 12px;font-size:0.8rem;">닫기
                ✕</button>
        </div>
        <div class="reference-panel-body">
            <pre><code class="language-python" id="referenceCode"></code></pre>
        </div>
    </div>

    <script src="../../shared/quiz-config.js"></script>
    <script src="../../shared/nav-config.js"></script>
    <script src="../../shared/sidebar.js"></script>
    <script src="../../shared/ai-chat.js"></script>
    <script>
        const REFERENCE_CODE = `class Node():
    def __init__(self):
        self.data = None
        self.link = None

def printNodes(start):
    current = start
    if current is None:
        print("(빈 리스트)")
        return

    print("현재 리스트:", end=' ')
    print(current.data, end=' ')
    while current.link is not None:
        current = current.link
        print(current.data, end=' ')
    print()

def get_list_data():
    result = []
    current = head
    while current is not None:
        result.append(current.data)
        current = current.link
    return result

def appendNode(newData):
    global head

    node = Node()
    node.data = newData

    if head is None:
        head = node
        return

    current = head
    while current.link is not None:
        current = current.link
    current.link = node

def insertNode(findData, insertData):
    global head
    
    if head is None:
        node = Node()
        node.data = insertData
        head = node
        return

    if head.data == findData:
        node = Node()
        node.data = insertData
        node.link = head
        head = node
        return

    current = head
    while current.link is not None:
        pre = current
        current = current.link
        if current.data == findData:
            node = Node()
            node.data = insertData
            node.link = current
            pre.link = node
            return

    node = Node()
    node.data = insertData
    current.link = node

def insertAt(index, data):
    global head
    
    if index < 0:
        print("인덱스는 0 이상이어야 합니다.")
        return

    newNode = Node()
    newNode.data = data

    if index == 0:
        newNode.link = head
        head = newNode
        return

    current = head
    currentIndex = 0
    
    while current is not None and currentIndex < index - 1:
        current = current.link
        currentIndex += 1
    
    if current is None:
        print("인덱스가 리스트의 길이를 초과했습니다.")
        return

    newNode.link = current.link
    current.link = newNode

def deleteNode(deleteData):
    global head, current, pre

    if head is None:
        print("삭제할 노드가 없습니다.(빈 리스트)")
        return

    if head.data == deleteData:
        current = head
        head = head.link
        del(current)
        return

    current = head
    while current.link is not None:
        pre = current
        current = current.link
        if current.data == deleteData:
            pre.link = current.link
            del(current)
            return

    print(f"'{deleteData}' 데이터를 찾을 수 없습니다.")

def clearList():
    global head

    head = None
    print("리스트가 초기화되었습니다.")

def searchNode(target):
    global head

    indexes = []
    current = head
    idx = 0
    while current is not None:
        if current.data == target:
            indexes.append(idx)
        current = current.link
        idx += 1
    return indexes

def saveToFile(filename):
    data_list = get_list_data()
    with open(filename, 'w', encoding='utf-8') as f:
        for item in data_list:
            f.write(str(item) + '\\n')
    print(f"리스트가 파일로 저장되었습니다. ({filename})")

def loadFromFile(filename):
    global head

    try:
        with open(filename, 'r', encoding='utf-8') as f:
            lines = f.readlines()
    except FileNotFoundError:
        print("파일을 찾을 수 없습니다.")
        return

    head = None
    for line in lines:
        data = line.strip()
        if data != '':
            appendNode(data)
    print(f"파일에서 리스트를 불러왔습니다. ({filename})")

memory = []
head, current, pre = None, None, None

if __name__ == "__main__":

    dataArray = ["서울대", "고대", "연대", "두원", "부산"]
    for data in dataArray:
        appendNode(data)
    
    print("초기 연결 리스트:")
    printNodes(head)

    select = -1
    while select != 9:
        print("\\n--- 연결 리스트 메뉴 ---")
        print("1: 추가 (맨 뒤)")
        print("2: 삽입 (특정 데이터 앞에 삽입)")
        print("3: 삽입 (특정 위치에 삽입)")
        print("4: 삭제 (특정 데이터 삭제 / 삭제 전 확인)")
        print("5: 리스트 초기화")
        print("6: 검색 (데이터 -> 인덱스)")
        print("7: 파일 저장")
        print("8: 파일 불러오기")
        print("9: 종료")

        try:
            select = int(input("메뉴 선택: "))
        except ValueError:
            print("숫자를 입력하세요.")
            continue

        if select == 1:
            data = input("추가할 데이터 입력: ")
            appendNode(data)
            printNodes(head)
        
        elif select == 2:
            findData = input("어느 데이터 앞에 삽입할까요? (찾을 데이터): ")
            insertData = input("삽입할 데이터 입력: ")
            insertNode(findData, insertData)
            printNodes(head)
        
        elif select == 3:
            try:
                idx = int(input("삽입할 인덱스 번호 입력: "))
                data = input("삽입할 데이터 입력: ")
                insertAt(idx, data)
                printNodes(head)
            except ValueError:
                print("인덱스는 숫자로 입력해야 합니다.")

        elif select == 4:
            delData = input("삭제할 데이터 입력: ")
            confirm = input(f"정말로 '{delData}'를 삭제할까요? (y/n): ")
            if confirm.lower() == 'y':
                deleteNode(delData)
                printNodes(head)
            else:
                print("삭제를 취소했습니다.")
                printNodes(head)

        elif select == 5:
            clearList()
            printNodes(head)

        elif select == 6:
            data = input("검색할 데이터 입력: ")
            indexes = searchNode(data)
            if indexes:
                print(f"'{data}' 데이터는 다음 인덱스에 있습니다: {indexes}")
            else:
                print(f"'{data}' 데이터는 리스트에 없습니다.")

        elif select == 7:
            filename = input("저장할 파일 이름 입력 (예: data.txt): ")
            saveToFile(filename)

        elif select == 8:
            filename = input("불러올 파일 이름 입력 (예: data.txt): ")
            loadFromFile(filename)
            printNodes(head)

        elif select == 9:
            print("프로그램을 종료합니다.")
        
        else:
            print("잘못된 선택입니다. 다시 입력하세요.")`;

        const editor = document.getElementById('practiceEditor');
        const lineNumbers = document.getElementById('lineNumbers');

        // ============================================
        // VSCode-style Editor Configuration
        // ============================================
        const EDITOR_CONFIG = {
            tabSize: 4,
            insertSpaces: true,
            indentUnit: '    ',  // 4 spaces
            scrollMarginLines: 5  // Keep cursor this many lines from bottom
        };
        const INDENT_SIZE = EDITOR_CONFIG.tabSize;

        // Python indentation rules (VSCode-style)
        const PYTHON_RULES = {
            // Lines ending with these trigger indent increase
            increaseIndentPattern: /:\s*(#.*)?$/,
            // Lines starting with these (or containing only these after indent) trigger outdent
            decreaseIndentPattern: /^\s*(return|pass|break|continue|raise|else:|elif\s+.*:|except.*:|finally:)/,
            // Outdent the NEXT line only
            outdentNextLinePattern: /^\s*(return|pass|break|continue|raise)\b/,
            // onEnter rules
            onEnterRules: [
                { beforeText: /:\s*(#.*)?$/, action: 'indent' },            // After colon
                { beforeText: /^\s*$/, action: 'outdent' },                  // Empty line = reduce indent
                { beforeText: /^\s*(return|pass|break|continue|raise)\b/, action: 'outdent' }  // After return/pass/etc
            ]
        };

        // Helper: Get leading whitespace from a line
        function getIndent(text) {
            const match = text.match(/^[\t ]*/);
            return match ? match[0] : '';
        }

        // Helper: Remove one indent level
        function removeOneIndent(text) {
            if (text.startsWith(EDITOR_CONFIG.indentUnit)) {
                return text.slice(EDITOR_CONFIG.indentUnit.length);
            }
            const match = text.match(/^[ ]+/);
            if (!match) return text;
            const toRemove = Math.min(match[0].length, EDITOR_CONFIG.tabSize);
            return text.slice(toRemove);
        }

        // Helper: Get full current line text
        function getCurrentLineText() {
            const text = editor.value;
            const cursorPos = editor.selectionStart;
            const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
            const lineEnd = text.indexOf('\n', cursorPos);
            return text.substring(lineStart, lineEnd === -1 ? text.length : lineEnd);
        }

        // Compute indent for new line (VSCode onEnterRules style)
        function computeIndentOnEnter(prevLineText) {
            const baseIndent = getIndent(prevLineText);
            const trimmedLine = prevLineText.trim();

            // Rule 1: Empty line = KEEP same indent (don't reduce)
            if (trimmedLine === '') {
                return baseIndent;
            }

            // Rule 2: Line ends with colon = increase indent
            if (PYTHON_RULES.increaseIndentPattern.test(prevLineText)) {
                return baseIndent + EDITOR_CONFIG.indentUnit;
            }

            // Rule 3: return/pass/break/continue = reduce indent
            if (PYTHON_RULES.outdentNextLinePattern.test(prevLineText)) {
                return removeOneIndent(baseIndent);
            }

            // Default: same indent as previous line
            return baseIndent;
        }

        // Line number update
        function updateLineNumbers() {
            const lines = editor.value.split('\n').length;
            lineNumbers.innerHTML = Array.from({ length: lines }, (_, i) => i + 1).join('<br>');
        }

        // Scroll sync
        editor.addEventListener('scroll', () => {
            lineNumbers.scrollTop = editor.scrollTop;
        });

        editor.addEventListener('input', () => {
            updateLineNumbers();
            scrollToCurrentLine();
        });

        // Insert text at cursor
        function insertAtCursor(text) {
            const start = editor.selectionStart;
            const end = editor.selectionEnd;
            editor.value = editor.value.substring(0, start) + text + editor.value.substring(end);
            editor.selectionStart = editor.selectionEnd = start + text.length;
        }

        // Get current line indent
        function getCurrentLineIndent() {
            const text = editor.value;
            const cursorPos = editor.selectionStart;
            const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
            let indent = 0;
            for (let i = lineStart; i < cursorPos && text[i] === ' '; i++) indent++;
            return indent;
        }

        // Check if current line is empty
        function isCurrentLineEmpty() {
            const text = editor.value;
            const cursorPos = editor.selectionStart;
            const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
            const lineEnd = text.indexOf('\n', cursorPos);
            const line = text.substring(lineStart, lineEnd === -1 ? text.length : lineEnd);
            return line.trim() === '';
        }

        // Get line before cursor
        function getLineBeforeCursor() {
            const text = editor.value;
            const cursorPos = editor.selectionStart;
            const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
            return text.substring(lineStart, cursorPos);
        }

        // Get current line number
        function getCurrentLineNumber() {
            const text = editor.value.substring(0, editor.selectionStart);
            return text.split('\n').length;
        }

        // Keyboard handling
        editor.addEventListener('keydown', function (e) {
            // Ctrl+/ - Toggle comment
            if (e.key === '/' && e.ctrlKey) {
                e.preventDefault();
                const text = editor.value;
                const cursorPos = editor.selectionStart;
                const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
                const lineEnd = text.indexOf('\n', cursorPos);
                const actualLineEnd = lineEnd === -1 ? text.length : lineEnd;
                const line = text.substring(lineStart, actualLineEnd);

                if (line.trimStart().startsWith('#')) {
                    // Remove comment
                    const hashIndex = line.indexOf('#');
                    const newLine = line.substring(0, hashIndex) + line.substring(hashIndex + 2);
                    editor.value = text.substring(0, lineStart) + newLine + text.substring(actualLineEnd);
                    editor.selectionStart = editor.selectionEnd = cursorPos - 2;
                } else {
                    // Add comment
                    const firstNonSpace = line.search(/\S/);
                    const insertPos = firstNonSpace === -1 ? 0 : firstNonSpace;
                    const newLine = line.substring(0, insertPos) + '# ' + line.substring(insertPos);
                    editor.value = text.substring(0, lineStart) + newLine + text.substring(actualLineEnd);
                    editor.selectionStart = editor.selectionEnd = cursorPos + 2;
                }
                updateLineNumbers();
                return;
            }

            // Ctrl+D - Select word at cursor
            if (e.key === 'd' && e.ctrlKey) {
                e.preventDefault();
                const text = editor.value;
                const cursorPos = editor.selectionStart;
                const wordChars = /[a-zA-Z0-9_]/;

                let start = cursorPos;
                let end = cursorPos;

                while (start > 0 && wordChars.test(text[start - 1])) start--;
                while (end < text.length && wordChars.test(text[end])) end++;

                if (start !== end) {
                    editor.selectionStart = start;
                    editor.selectionEnd = end;
                }
                return;
            }

            // Ctrl+Shift+K - Delete line
            if (e.key === 'K' && e.ctrlKey && e.shiftKey) {
                e.preventDefault();
                const text = editor.value;
                const cursorPos = editor.selectionStart;
                const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
                const lineEnd = text.indexOf('\n', cursorPos);

                if (lineEnd === -1) {
                    editor.value = text.substring(0, lineStart > 0 ? lineStart - 1 : 0);
                } else {
                    editor.value = text.substring(0, lineStart) + text.substring(lineEnd + 1);
                }
                editor.selectionStart = editor.selectionEnd = lineStart;
                updateLineNumbers();
                return;
            }

            // Alt+Up/Down - Move line
            if ((e.key === 'ArrowUp' || e.key === 'ArrowDown') && e.altKey) {
                e.preventDefault();
                const text = editor.value;
                const cursorPos = editor.selectionStart;
                const lines = text.split('\n');

                let charCount = 0;
                let currentLineIndex = 0;
                for (let i = 0; i < lines.length; i++) {
                    if (charCount + lines[i].length >= cursorPos) {
                        currentLineIndex = i;
                        break;
                    }
                    charCount += lines[i].length + 1;
                }

                const targetIndex = e.key === 'ArrowUp' ? currentLineIndex - 1 : currentLineIndex + 1;
                if (targetIndex >= 0 && targetIndex < lines.length) {
                    const temp = lines[currentLineIndex];
                    lines[currentLineIndex] = lines[targetIndex];
                    lines[targetIndex] = temp;
                    editor.value = lines.join('\n');

                    // Calculate new cursor position
                    let newPos = 0;
                    for (let i = 0; i < targetIndex; i++) {
                        newPos += lines[i].length + 1;
                    }
                    editor.selectionStart = editor.selectionEnd = newPos;
                }
                updateLineNumbers();
                return;
            }

            // Ctrl+Enter - Insert line below
            if (e.key === 'Enter' && e.ctrlKey) {
                e.preventDefault();
                const text = editor.value;
                const cursorPos = editor.selectionStart;
                const lineEnd = text.indexOf('\n', cursorPos);
                const insertPos = lineEnd === -1 ? text.length : lineEnd;

                editor.value = text.substring(0, insertPos) + '\n' + text.substring(insertPos);
                editor.selectionStart = editor.selectionEnd = insertPos + 1;
                updateLineNumbers();
                syncReferenceHighlight();
                return;
            }

            // Home - Smart home (toggle between line start and first non-space)
            // Shift+Home - Select from cursor to home position
            if (e.key === 'Home' && !e.ctrlKey) {
                e.preventDefault();
                const text = editor.value;
                const cursorPos = editor.selectionStart;
                const selectionEnd = editor.selectionEnd;
                const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
                const lineEnd = text.indexOf('\n', cursorPos);
                const line = text.substring(lineStart, lineEnd === -1 ? text.length : lineEnd);
                const firstNonSpace = line.search(/\S/);
                const firstNonSpacePos = firstNonSpace === -1 ? lineStart : lineStart + firstNonSpace;

                let targetPos;
                if (cursorPos === firstNonSpacePos) {
                    targetPos = lineStart;
                } else {
                    targetPos = firstNonSpacePos;
                }

                if (e.shiftKey) {
                    // Select from current position to target
                    editor.selectionStart = targetPos;
                    editor.selectionEnd = selectionEnd;
                } else {
                    editor.selectionStart = editor.selectionEnd = targetPos;
                }
                return;
            }

            // End - Move to end of line
            // Shift+End - Select from cursor to end of line
            if (e.key === 'End' && !e.ctrlKey) {
                e.preventDefault();
                const text = editor.value;
                const cursorPos = editor.selectionStart;
                const lineEnd = text.indexOf('\n', cursorPos);
                const endPos = lineEnd === -1 ? text.length : lineEnd;

                if (e.shiftKey) {
                    // Select from current position to end
                    editor.selectionStart = cursorPos;
                    editor.selectionEnd = endPos;
                } else {
                    editor.selectionStart = editor.selectionEnd = endPos;
                }
                return;
            }

            // Auto-close brackets and quotes
            const pairs = { '(': ')', '[': ']', '{': '}', '"': '"', "'": "'" };
            if (pairs[e.key]) {
                e.preventDefault();
                const start = editor.selectionStart;
                const end = editor.selectionEnd;
                const selected = editor.value.substring(start, end);

                if (selected.length > 0) {
                    // Wrap selection
                    insertAtCursor(e.key + selected + pairs[e.key]);
                    editor.selectionStart = start + 1;
                    editor.selectionEnd = end + 1;
                } else {
                    // Insert pair
                    insertAtCursor(e.key + pairs[e.key]);
                    editor.selectionStart = editor.selectionEnd = start + 1;
                }
                return;
            }

            // Shift+Enter - Move to next line with proper indentation (no new line insertion)
            // IMPORTANT: Never move to a position with LESS indent than current line
            if (e.key === 'Enter' && e.shiftKey) {
                e.preventDefault();
                const text = editor.value;
                const cursorPos = editor.selectionStart;

                // Get current line info
                const currentLineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
                const currentLineEnd = text.indexOf('\n', cursorPos);
                const currentLine = text.substring(currentLineStart, currentLineEnd === -1 ? text.length : currentLineEnd);
                const currentIndent = getIndent(currentLine);
                const minIndentLength = currentIndent.length;  // Minimum indent to maintain

                // Calculate target indent (add 4 spaces if line ends with colon)
                const endsWithColon = currentLine.trim().endsWith(':');
                const targetIndent = endsWithColon
                    ? currentIndent + EDITOR_CONFIG.indentUnit
                    : currentIndent;

                if (currentLineEnd !== -1) {
                    // Move to next line
                    const nextLineStart = currentLineEnd + 1;

                    // Get next line's content to check its indent
                    const nextLineEnd = text.indexOf('\n', nextLineStart);
                    const nextLine = text.substring(nextLineStart, nextLineEnd === -1 ? text.length : nextLineEnd);
                    const nextLineIndent = getIndent(nextLine);

                    // Use the GREATER of: target indent OR minimum indent from current line
                    const finalIndentLength = Math.max(targetIndent.length, minIndentLength);

                    // Don't go past end of next line
                    const maxPos = nextLineEnd === -1 ? text.length : nextLineEnd;
                    const targetPos = Math.min(nextLineStart + finalIndentLength, maxPos);

                    editor.selectionStart = editor.selectionEnd = targetPos;
                } else {
                    // No next line - create new line with indent
                    editor.value = text + '\n' + targetIndent;
                    editor.selectionStart = editor.selectionEnd = text.length + 1 + targetIndent.length;
                    updateLineNumbers();
                }
                return;
            }

            if (e.key === 'Enter') {
                e.preventDefault();
                const currentLineText = getCurrentLineText();

                // Use VSCode-style indent computation
                const newIndent = computeIndentOnEnter(currentLineText);
                insertAtCursor('\n' + newIndent);
                updateLineNumbers();
                scrollToCurrentLine();
                syncReferenceHighlight();
                return;
            }

            if (e.key === 'Tab') {
                e.preventDefault();
                const text = editor.value;
                const start = editor.selectionStart;
                const end = editor.selectionEnd;

                // Check if there's a multi-line selection
                const hasSelection = start !== end;
                const selectedText = text.substring(start, end);
                const hasMultipleLines = hasSelection && selectedText.includes('\n');

                if (hasMultipleLines) {
                    // Multi-line indent/outdent
                    const lineStart = text.lastIndexOf('\n', start - 1) + 1;
                    const lineEnd = text.indexOf('\n', end - 1);
                    const actualEnd = lineEnd === -1 ? text.length : lineEnd;
                    const linesText = text.substring(lineStart, actualEnd);
                    const lines = linesText.split('\n');

                    let newLines;
                    if (e.shiftKey) {
                        // Outdent all selected lines
                        newLines = lines.map(line => removeOneIndent(line));
                    } else {
                        // Indent all selected lines
                        newLines = lines.map(line => EDITOR_CONFIG.indentUnit + line);
                    }

                    const newText = newLines.join('\n');
                    editor.value = text.substring(0, lineStart) + newText + text.substring(actualEnd);

                    // Adjust selection
                    const lengthDiff = newText.length - linesText.length;
                    editor.selectionStart = lineStart;
                    editor.selectionEnd = lineStart + newText.length;
                } else if (e.shiftKey) {
                    // Single line outdent
                    const cursorPos = start;
                    const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
                    let removeCount = 0;
                    for (let i = 0; i < INDENT_SIZE && lineStart + i < cursorPos; i++) {
                        if (text[lineStart + i] === ' ') removeCount++;
                        else break;
                    }
                    if (removeCount > 0) {
                        editor.value = text.substring(0, lineStart) + text.substring(lineStart + removeCount);
                        editor.selectionStart = editor.selectionEnd = cursorPos - removeCount;
                    }
                } else {
                    // Single cursor: insert indent
                    insertAtCursor(EDITOR_CONFIG.indentUnit);
                }
                updateLineNumbers();
                return;
            }

            if (e.key === 'Backspace') {
                const cursorPos = editor.selectionStart;
                const text = editor.value;
                const lineStart = text.lastIndexOf('\n', cursorPos - 1) + 1;
                const textBeforeCursor = text.substring(lineStart, cursorPos);
                const positionInLine = cursorPos - lineStart;

                // Only smart-delete if: all spaces before cursor AND at 4-char boundary (4, 8, 12...)
                if (textBeforeCursor.length > 0 && textBeforeCursor.trim() === '' && positionInLine % INDENT_SIZE === 0) {
                    e.preventDefault();
                    const removeCount = Math.min(INDENT_SIZE, textBeforeCursor.length);
                    editor.value = text.substring(0, cursorPos - removeCount) + text.substring(cursorPos);
                    editor.selectionStart = editor.selectionEnd = cursorPos - removeCount;
                    updateLineNumbers();
                    return;
                }
            }
        });

        // Sync cursor with reference highlight
        editor.addEventListener('keyup', syncReferenceHighlight);
        editor.addEventListener('click', syncReferenceHighlight);

        function syncReferenceHighlight() {
            const lineNum = getCurrentLineNumber();
            const refLines = document.querySelectorAll('.ref-line');
            refLines.forEach((el, i) => {
                el.classList.toggle('active', i + 1 === lineNum);
            });

            // Scroll reference to current line
            const activeLine = document.querySelector('.ref-line.active');
            if (activeLine) {
                activeLine.scrollIntoView({ block: 'center', behavior: 'smooth' });
            }

            // Scroll reference panel to current line
            scrollToCurrentLine();
        }

        // Keep cursor line ALWAYS at 35% from top of viewport
        function scrollToCurrentLine() {
            requestAnimationFrame(() => {
                const lineNum = getCurrentLineNumber();

                const computedStyle = getComputedStyle(editor);
                let lineHeight = parseFloat(computedStyle.lineHeight);
                const paddingTop = parseFloat(computedStyle.paddingTop) || 0;

                // Fallback for line-height being 'normal' or NaN
                if (isNaN(lineHeight) || lineHeight <= 0) {
                    lineHeight = 20;
                }

                const viewportHeight = editor.clientHeight;
                const totalScrollHeight = editor.scrollHeight;

                // Current line Y position (content-relative)
                const lineTop = paddingTop + (lineNum - 1) * lineHeight;

                // Target ratio: 0.0 = top, 0.5 = center, 0.35 = upper-center
                const targetRatio = 0.35;

                // Calculate scrollTop so this line is at targetRatio position
                const targetScrollTop = lineTop - viewportHeight * targetRatio;

                // Clamp to valid scroll range
                const maxScrollTop = Math.max(0, totalScrollHeight - viewportHeight);
                const finalScrollTop = Math.min(Math.max(targetScrollTop, 0), maxScrollTop);

                editor.scrollTop = finalScrollTop;
                lineNumbers.scrollTop = finalScrollTop;
            });
        }

        // Reference panel
        function toggleReference() {
            const panel = document.getElementById('referencePanel');
            panel.classList.toggle('show');
            document.body.classList.toggle('reference-open', panel.classList.contains('show'));
            if (panel.classList.contains('show')) {
                setTimeout(syncReferenceHighlight, 100);
            }
        }

        function clearEditor() {
            if (confirm('정말로 전체 내용을 지우시겠습니까?')) {
                editor.value = '';
                updateLineNumbers();
                editor.focus();
            }
        }

        function copyToClipboard() {
            navigator.clipboard.writeText(editor.value).then(() => {
                alert('클립보드에 복사되었습니다!');
            });
        }

        // Initialize reference with line wrappers
        document.addEventListener('DOMContentLoaded', () => {
            const lines = REFERENCE_CODE.split('\n');
            const codeEl = document.getElementById('referenceCode');
            codeEl.innerHTML = lines.map((line, i) =>
                `<span class="ref-line" data-line="${i + 1}">${Prism.highlight(line, Prism.languages.python, 'python') || ' '}</span>`
            ).join('');

            updateLineNumbers();
            editor.focus();
        });

        // Expose functions
        window.toggleReference = toggleReference;
        window.clearEditor = clearEditor;
        window.copyToClipboard = copyToClipboard;
    </script>
</body>

</html>